---
title: Run tasks in the background
description: See examples of using Prefect tasks and the task worker.
---

Prefect tasks help you quickly execute small, discrete units of work. _Deferred_ Prefect tasks run in a 
background process using a Prefect task worker. Use deferred tasks to move work out of the foreground of your 
application and distribute concurrent execution across multiple processes or machines.

For example, if you have a web application, deferred tasks allow you to offload processes such as sending emails, processing 
images, or inserting data into a database.

## Using deferred tasks

Prefect tasks are Python functions that can be run immediately or deferred for background execution.

Define a task by adding the `@task` decorator to a Python function, and use the `delay` method to 
run the task in the background.

If you schedule the task for background execution, you can run a task worker in a separate process or container to execute 
the task. This process is similar to a Celery worker or an arq worker.

### Defining a task

Add the `@task` decorator to a Python function to define a Prefect task:

```python
from prefect import task

@task
def my_background_task(name: str):
    # Task logic here
    print(f"Hello, {name}!")
```

### Calling tasks

You can call a task to run it immediately, or you can defer the task by scheduling it for background execution with 
`Task.delay`.

<Note>
You can submit tasks to a _task runner_ such as Ray or Dask within 
a workflow, which in Prefect is called a _flow_. However, this guide focuses on deferring task execution outside of 
workflows. For example, by calling `my_task.delay()` within a web application.
</Note>

However you run a task, Prefect uses your task configuration to manage and control task execution.
The following example shows both methods of calling a task and using `delay`:

```python
# Import the previously-defined task
from myproject.tasks import my_background_task

# Run the task immediately
my_background_task("Joaquim")

# Schedule the task for execution outside of this process
my_background_task.delay("Agrajag")
```

### Executing deferred tasks with a task worker

To run tasks in a separate process or container, start a task worker.

The task worker continually receives instructions to execute deferred tasks from Prefect's API, executes them, and 
reports the results back to the API.

<Note>
Task workers only run deferred tasks, not tasks you call directly as normal Python functions.
</Note>

Run a task worker by passing tasks into the `prefect.task_worker.serve()` method:

```python tasks.py
from prefect import task
from prefect.task_worker import serve


@task
def my_background_task(name: str):
    # Task logic here
    print(f"Hello, {name}!")


if __name__ == "__main__":
    # NOTE: The serve() function accepts multiple tasks. The Task worker 
    # will listen for scheduled task runs for all tasks passed in.
    serve(my_background_task)
```

The task worker begins listening for scheduled tasks. If tasks were scheduled before the task worker started, 
it will begin processing them.

You can also use the helper CLI command `prefect task serve` to start a task worker:

```bash
prefect task serve my_task.py:my_background_task
```

## Guided exploration of deferred tasks and task workers in Prefect

Here are some examples of using deferred tasks and task workers in Prefect.

You will:

- run a Prefect task in the foreground by calling it
- start a task worker and defer tasks so that they run in the background
- create a basic FastAPI application that defers tasks when you hit an endpoint
- use Docker in two examples that mimic real use cases

One example uses a FastAPI server with multiple microservices and simulates a new user signup workflow.
The other example uses a Flask server with [Marvin](https://www.askmarvin.ai/) to ask questions of an LLM from the CLI 
and get back answers.

---
title: What's new in Prefect 3.0
sidebarTitle: What's new
---

Prefect 3.0 introduces a number of enhancements to the OSS product: a new events & automations backend for event-driven workflows and observability, improved runtime performance, autonomous task execution and a streamlined caching layer based on transactional semantics.

Most Prefect 2.0 users can upgrade without changes to their existing workflows. Please review the [upgrade guide](/3.0/resources/upgrade-to-prefect-3) for more information.

<Info>
**Prefect 2.0** refers to the 2.x lineage of the open source prefect package, and **Prefect 3.0** refers exclusively to the 3.x lineage of the prefect package. Neither version is strictly tied to any aspect of Prefect's commercial product, [Prefect Cloud](/3.0/manage/cloud). 
</Info>

## Open source events and automation system

One of the largest features in Prefect 3.0 is the introduction of the events and automation system to the open source package. Previously exclusive to Prefect Cloud, this system now allows all users to create event-driven workflows and automate their system based on the presence or absence of observable events. 

With this new capability, you can trigger actions based on specific event payloads, cancel runs if certain conditions aren't met, or automate workflow runs based on external events. For instance, you could initiate a data processing pipeline automatically when a new file lands in an S3 bucket. The system also enables you to receive notifications for various system health events, giving you greater visibility and control over your workflows.

## New transactional interface

Another major addition in Prefect 3.0 is the new transactional interface. This powerful feature makes it easier than ever to build resilient and idempotent pipelines. With the transactional interface, you can group tasks into transactions, automatically roll back side effects on failure, and significantly improve your pipeline's idempotency and resilience.

For example, you can define rollback behaviors for your tasks, ensuring that any side effects are cleanly reversed if a transaction fails. This is particularly useful for maintaining data consistency in complex workflows involving multiple steps or external systems.

## Flexible task execution

Prefect 3.0 has no restrictions on where tasks can run. Tasks can be nested within other tasks, allowing for more flexible and modular workflows; they can also be called outside of flows, essentially enabling Prefect to function as a background task service. You can now run tasks autonomously, apply them asynchronously, or delay their execution as needed. This flexibility opens up new possibilities for task management and execution strategies in your data pipelines.

## Enhanced client-side engine

Prefect 3.0 comes with a thoroughly reworked client-side engine that brings several improvements to the table. You can now nest tasks within other tasks, adding a new level of modularity to your workflows. The engine also supports generator tasks, allowing for more flexible and efficient handling of iterative processes.

One of the most significant changes is that all code now runs on the main thread by default. This change improves performance and leads to more intuitive behavior, especially when dealing with shared resources or non-thread-safe operations.

## Improved artifacts and variables

Prefect 3.0 enhances the artifacts system with new types, including progress bars and image artifacts. These additions allow for richer, more informative task outputs, improving the observability of your workflows.

The variables system has also been upgraded to support arbitrary JSON, not just strings. This expansion allows for more complex and structured data to be stored and retrieved as variables, increasing the flexibility of your workflow configurations.

## Workers

Workers were first introduced in Prefect 2.0 as next-generation agents, and are now standard in Prefect 3.0. Workers offer a stronger governance model for infrastructure, improved monitoring of jobs and work pool/queue health, and more flexibility in choosing compute layers, resulting in a more robust and scalable solution for managing the execution of your workflows across various environments.

Worker logs are now sent to the API only if a worker ID is present, indicating a connection to Prefect Cloud. This change simplifies the logging configuration and ensures logs are only sent when supported by the backend. The `PREFECT_EXPERIMENTS_WORKER_LOGGING_TO_API_ENABLED` environment variable has been removed, and users should update their configurations to align with the new logging behavior.

## Performance enhancements

Prefect 3.0 doesn't just bring new features; it also delivers significant performance improvements. Users running massively parallel workflows on distributed systems such as Dask and Ray will notice substantial speedups. In some benchmark cases, we've observed up to a 98% reduction in runtime overhead. These performance gains translate directly into faster execution times and more efficient resource utilization for your data pipelines.

## Release notes

See release notes for each released version in the [Gitub repository](https://github.com/PrefectHQ/prefect/releases).

### Example 1: Run a Prefect task in the foreground by calling it

<summary>Expand</summary>

Add the `@task` decorator to any Python function to define a Prefect task.

#### Step 1: Create a file with a task-decorated function 

Create a file and save the following code in it, or run the existing file in the 
basic-examples directory.

```python greeter.py
from prefect import task 

@task(log_prints=True)
def greet(name: str = "Marvin"):
    print(f"Hello, {name}!")

if __name__ == "__main__":
    greet()
```

#### Step 2: Run the script in the terminal

```bash
python greeter.py
```

You should see the task run in the terminal. This task runs in the foreground, meaning it is not deferred.

#### Optional

You can see the task run in the UI.
If you're using a self-hosted Prefect server instance, you can also see the task runs in the database.

If you want to inspect the SQLite database, use your favorite interface.
*DB Browser for SQLite* is explained below.

Download it [here](https://sqlitebrowser.org/dl/), if needed. Install it and open it.

Click *Connect*. Then navigate to your SQLite DB file. It's located in `~/.prefect` directory by default.

Go to the `task_run` table to see all your task runs there.
Scroll down to see your most recent task runs or filter for them.

Hit the refresh button for updates, if needed.

### Example 2: Start a task worker and run deferred tasks in the background

To run tasks in a separate process or container, start a task worker, similar to how you would run a 
Celery worker or an arq worker.
The task worker continually receives scheduled tasks to execute from Prefect's API, executes them, and reports the 
results back to the API.
Run a task worker by passing tasks into the `prefect.task_worker.serve()` method.

#### Step 1: Define the task and task worker in a file 

```python task_worker.py
from prefect import task
from prefect.task_worker import serve


@task
def my_background_task(name: str):
    print(f"Hello, {name}!")


if __name__ == "__main__":
    serve(my_background_task)
```

#### Step 2: Start the task worker by running the script in the terminal

```bash
python task_worker.py
```

The task worker is waiting for runs of the `my_background_task` task.

#### Step 3: Create a file and save the following code in it:

{/* pmd-metadata: notest */}
```python task_scheduler.py
from task_worker import my_background_task


if __name__ == "__main__":
    my_background_task.delay("Agrajag")
```

#### Step 4: Open another terminal and run the script

```bash
python task_scheduler.py
```

The code returns a "future" from the `delay` method. You can use this object to wait for the task to complete with 
`wait()` and to retrieve its result with `result()`.
You can also see the task run's UUID and other information about the task run.

#### Step 5: See the task run in the UI

Use the task run UUID to see the task run in the UI.
The URL will look like this:

`http://127.0.0.1:4200/task-runs/task-run/my_task_run_uuid_goes_here`

Substitute your UUID at the end of the URL.

#### Step 6: Use multiple task workers to run tasks in parallel

Start another instance of the task worker. In another terminal run:

```bash
python task_worker.py
```

#### Step 7: Send multiple tasks to the task worker

Modify the `task_scheduler.py` file to send multiple tasks to the task worker with different inputs:

{/* pmd-metadata: notest */}
```python
from task_worker import my_background_task

if __name__ == "__main__":
    my_background_task.delay("Ford")
    my_background_task.delay("Prefect")
    my_background_task.delay("Slartibartfast")
```

Run the file to see the work get distributed across both task workers.

#### Step 8: Shut down the task workers with *control* + *c*

This guide showed you how to send tasks to multiple Prefect task workers running in the background.
This allows you to observe these tasks executing in parallel and very quickly with web sockets, with no polling required.

See additional examples in the [deferred tasks GitHub repository](https://github.com/PrefectHQ/prefect-background-task-examples.git).